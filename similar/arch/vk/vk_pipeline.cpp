/*
 * This file is part of the DXX-Rebirth project <https://www.dxx-rebirth.com/>.
 * Vulkan renderer - pipeline creation.
 */

#include "dxxsconf.h"
#if DXX_USE_VULKAN

#include "vk_common.h"
#include "console.h"

// Embedded SPIR-V shaders (generated by glslangValidator at build time)
// Defined at global scope in vk_shaders.cpp
extern const uint32_t basic_vert_spv[];
extern const uint32_t basic_vert_spv_size;
extern const uint32_t basic_frag_spv[];
extern const uint32_t basic_frag_spv_size;
extern const uint32_t textured_vert_spv[];
extern const uint32_t textured_vert_spv_size;
extern const uint32_t textured_frag_spv[];
extern const uint32_t textured_frag_spv_size;

namespace dcx {

static VkShaderModule create_shader_module(const uint32_t *code, uint32_t size)
{
	VkShaderModuleCreateInfo ci{};
	ci.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
	ci.codeSize = size;
	ci.pCode = code;

	VkShaderModule module;
	if (vkCreateShaderModule(g_vk.device, &ci, nullptr, &module) != VK_SUCCESS)
		return VK_NULL_HANDLE;
	return module;
}

static VkPipeline create_pipeline(
	VkShaderModule vert, VkShaderModule frag,
	VkPrimitiveTopology topology,
	bool depth_test, bool depth_write,
	VkBlendFactor src_blend, VkBlendFactor dst_blend,
	float line_width)
{
	std::array<VkPipelineShaderStageCreateInfo, 2> stages{};
	stages[0].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	stages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
	stages[0].module = vert;
	stages[0].pName = "main";
	stages[1].sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
	stages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;
	stages[1].module = frag;
	stages[1].pName = "main";

	// Vertex input: position(3) + color(4) + texcoord(2)
	VkVertexInputBindingDescription binding{};
	binding.binding = 0;
	binding.stride = sizeof(vk_vertex);
	binding.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

	std::array<VkVertexInputAttributeDescription, 3> attrs{};
	attrs[0] = {0, 0, VK_FORMAT_R32G32B32_SFLOAT, offsetof(vk_vertex, x)};
	attrs[1] = {1, 0, VK_FORMAT_R32G32B32A32_SFLOAT, offsetof(vk_vertex, r)};
	attrs[2] = {2, 0, VK_FORMAT_R32G32_SFLOAT, offsetof(vk_vertex, u)};

	VkPipelineVertexInputStateCreateInfo vertex_input{};
	vertex_input.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
	vertex_input.vertexBindingDescriptionCount = 1;
	vertex_input.pVertexBindingDescriptions = &binding;
	vertex_input.vertexAttributeDescriptionCount = static_cast<uint32_t>(attrs.size());
	vertex_input.pVertexAttributeDescriptions = attrs.data();

	VkPipelineInputAssemblyStateCreateInfo input_assembly{};
	input_assembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
	input_assembly.topology = topology;

	// Dynamic viewport and scissor
	VkPipelineViewportStateCreateInfo viewport_state{};
	viewport_state.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
	viewport_state.viewportCount = 1;
	viewport_state.scissorCount = 1;

	VkPipelineRasterizationStateCreateInfo raster{};
	raster.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
	raster.polygonMode = VK_POLYGON_MODE_FILL;
	raster.cullMode = VK_CULL_MODE_NONE;  // DXX uses GL_FRONT cull, but we disable by default
	raster.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;
	raster.lineWidth = line_width;

	VkPipelineMultisampleStateCreateInfo multisample{};
	multisample.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
	multisample.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

	VkPipelineDepthStencilStateCreateInfo depth_stencil{};
	depth_stencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
	depth_stencil.depthTestEnable = depth_test ? VK_TRUE : VK_FALSE;
	depth_stencil.depthWriteEnable = depth_write ? VK_TRUE : VK_FALSE;
	depth_stencil.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;

	VkPipelineColorBlendAttachmentState blend_att{};
	blend_att.blendEnable = VK_TRUE;
	blend_att.srcColorBlendFactor = src_blend;
	blend_att.dstColorBlendFactor = dst_blend;
	blend_att.colorBlendOp = VK_BLEND_OP_ADD;
	blend_att.srcAlphaBlendFactor = src_blend;
	blend_att.dstAlphaBlendFactor = dst_blend;
	blend_att.alphaBlendOp = VK_BLEND_OP_ADD;
	blend_att.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
	                           VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;

	VkPipelineColorBlendStateCreateInfo blend{};
	blend.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
	blend.attachmentCount = 1;
	blend.pAttachments = &blend_att;

	std::array<VkDynamicState, 2> dynamic_states = {
		VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR
	};
	VkPipelineDynamicStateCreateInfo dynamic{};
	dynamic.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
	dynamic.dynamicStateCount = static_cast<uint32_t>(dynamic_states.size());
	dynamic.pDynamicStates = dynamic_states.data();

	VkGraphicsPipelineCreateInfo pci{};
	pci.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
	pci.stageCount = static_cast<uint32_t>(stages.size());
	pci.pStages = stages.data();
	pci.pVertexInputState = &vertex_input;
	pci.pInputAssemblyState = &input_assembly;
	pci.pViewportState = &viewport_state;
	pci.pRasterizationState = &raster;
	pci.pMultisampleState = &multisample;
	pci.pDepthStencilState = &depth_stencil;
	pci.pColorBlendState = &blend;
	pci.pDynamicState = &dynamic;
	pci.layout = g_vk.pipeline_layout;
	pci.renderPass = g_vk.render_pass;
	pci.subpass = 0;

	VkPipeline pipeline;
	if (vkCreateGraphicsPipelines(g_vk.device, VK_NULL_HANDLE, 1, &pci, nullptr, &pipeline) != VK_SUCCESS)
		return VK_NULL_HANDLE;
	return pipeline;
}

bool vk_create_pipelines()
{
	// Pipeline layout: push constants + 1 descriptor set (textures)
	VkPushConstantRange push_range{};
	push_range.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
	push_range.offset = 0;
	push_range.size = sizeof(vk_push_constants);

	VkPipelineLayoutCreateInfo plci{};
	plci.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
	plci.setLayoutCount = 1;
	plci.pSetLayouts = &g_vk.descriptor_set_layout;
	plci.pushConstantRangeCount = 1;
	plci.pPushConstantRanges = &push_range;

	if (vkCreatePipelineLayout(g_vk.device, &plci, nullptr, &g_vk.pipeline_layout) != VK_SUCCESS)
	{
		con_puts(CON_URGENT, "VK: Failed to create pipeline layout");
		return false;
	}

	// Load shader modules
	VkShaderModule basic_vert = create_shader_module(basic_vert_spv, basic_vert_spv_size);
	VkShaderModule basic_frag = create_shader_module(basic_frag_spv, basic_frag_spv_size);
	VkShaderModule tex_vert = create_shader_module(textured_vert_spv, textured_vert_spv_size);
	VkShaderModule tex_frag = create_shader_module(textured_frag_spv, textured_frag_spv_size);

	if (!basic_vert || !basic_frag || !tex_vert || !tex_frag)
	{
		con_puts(CON_URGENT, "VK: Failed to create shader modules");
		return false;
	}

	// Blend mode parameters
	struct blend_params {
		VkBlendFactor src, dst;
	};
	static constexpr blend_params blends[VK_BLEND_COUNT] = {
		{VK_BLEND_FACTOR_SRC_ALPHA, VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA},  // normal
		{VK_BLEND_FACTOR_SRC_ALPHA, VK_BLEND_FACTOR_ONE},                  // additive_a
		{VK_BLEND_FACTOR_ONE, VK_BLEND_FACTOR_ONE},                        // additive_c
	};

	for (int b = 0; b < VK_BLEND_COUNT; b++)
	{
		// Textured 3D
		g_vk.pipelines[VK_PIPE_TEXTURED_3D][b] = create_pipeline(
			tex_vert, tex_frag, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
			true, true, blends[b].src, blends[b].dst, 1.0f);

		// Flat 3D
		g_vk.pipelines[VK_PIPE_FLAT_3D][b] = create_pipeline(
			basic_vert, basic_frag, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
			true, true, blends[b].src, blends[b].dst, 1.0f);

		// Line 3D
		g_vk.pipelines[VK_PIPE_LINE_3D][b] = create_pipeline(
			basic_vert, basic_frag, VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
			true, false, blends[b].src, blends[b].dst, 1.0f);

		// Textured 2D
		g_vk.pipelines[VK_PIPE_TEXTURED_2D][b] = create_pipeline(
			tex_vert, tex_frag, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
			false, false, blends[b].src, blends[b].dst, 1.0f);

		// Flat 2D
		g_vk.pipelines[VK_PIPE_FLAT_2D][b] = create_pipeline(
			basic_vert, basic_frag, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
			false, false, blends[b].src, blends[b].dst, 1.0f);

		// Line 2D
		g_vk.pipelines[VK_PIPE_LINE_2D][b] = create_pipeline(
			basic_vert, basic_frag, VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
			false, false, blends[b].src, blends[b].dst, 1.0f);
	}

	// Cleanup shader modules (no longer needed after pipeline creation)
	vkDestroyShaderModule(g_vk.device, basic_vert, nullptr);
	vkDestroyShaderModule(g_vk.device, basic_frag, nullptr);
	vkDestroyShaderModule(g_vk.device, tex_vert, nullptr);
	vkDestroyShaderModule(g_vk.device, tex_frag, nullptr);

	// Verify all pipelines were created
	for (int p = 0; p < VK_PIPE_COUNT; p++)
		for (int b = 0; b < VK_BLEND_COUNT; b++)
			if (!g_vk.pipelines[p][b])
			{
				con_printf(CON_URGENT, "VK: Failed to create pipeline %d blend %d", p, b);
				return false;
			}

	con_puts(CON_DEBUG, "VK: All pipelines created");
	return true;
}

void vk_destroy_pipelines()
{
	for (int p = 0; p < VK_PIPE_COUNT; p++)
		for (int b = 0; b < VK_BLEND_COUNT; b++)
			if (g_vk.pipelines[p][b])
			{
				vkDestroyPipeline(g_vk.device, g_vk.pipelines[p][b], nullptr);
				g_vk.pipelines[p][b] = VK_NULL_HANDLE;
			}
	if (g_vk.pipeline_layout)
	{
		vkDestroyPipelineLayout(g_vk.device, g_vk.pipeline_layout, nullptr);
		g_vk.pipeline_layout = VK_NULL_HANDLE;
	}
}

}  // namespace dcx

#endif  // DXX_USE_VULKAN
